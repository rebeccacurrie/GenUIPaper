// src/types.ts
import { z } from "zod";
var DynamicValueSchema = z.union([
  z.string(),
  z.number(),
  z.boolean(),
  z.null(),
  z.object({ $state: z.string() })
]);
var DynamicStringSchema = z.union([
  z.string(),
  z.object({ $state: z.string() })
]);
var DynamicNumberSchema = z.union([
  z.number(),
  z.object({ $state: z.string() })
]);
var DynamicBooleanSchema = z.union([
  z.boolean(),
  z.object({ $state: z.string() })
]);
function resolveDynamicValue(value, stateModel) {
  if (value === null || value === void 0) {
    return void 0;
  }
  if (typeof value === "object" && "$state" in value) {
    return getByPath(stateModel, value.$state);
  }
  return value;
}
function unescapeJsonPointer(token) {
  return token.replace(/~1/g, "/").replace(/~0/g, "~");
}
function parseJsonPointer(path) {
  const raw = path.startsWith("/") ? path.slice(1).split("/") : path.split("/");
  return raw.map(unescapeJsonPointer);
}
function getByPath(obj, path) {
  if (!path || path === "/") {
    return obj;
  }
  const segments = parseJsonPointer(path);
  let current = obj;
  for (const segment of segments) {
    if (current === null || current === void 0) {
      return void 0;
    }
    if (Array.isArray(current)) {
      const index = parseInt(segment, 10);
      current = current[index];
    } else if (typeof current === "object") {
      current = current[segment];
    } else {
      return void 0;
    }
  }
  return current;
}
function isNumericIndex(str) {
  return /^\d+$/.test(str);
}
function setByPath(obj, path, value) {
  const segments = parseJsonPointer(path);
  if (segments.length === 0) return;
  let current = obj;
  for (let i = 0; i < segments.length - 1; i++) {
    const segment = segments[i];
    const nextSegment = segments[i + 1];
    const nextIsNumeric = nextSegment !== void 0 && (isNumericIndex(nextSegment) || nextSegment === "-");
    if (Array.isArray(current)) {
      const index = parseInt(segment, 10);
      if (current[index] === void 0 || typeof current[index] !== "object") {
        current[index] = nextIsNumeric ? [] : {};
      }
      current = current[index];
    } else {
      if (!(segment in current) || typeof current[segment] !== "object") {
        current[segment] = nextIsNumeric ? [] : {};
      }
      current = current[segment];
    }
  }
  const lastSegment = segments[segments.length - 1];
  if (Array.isArray(current)) {
    if (lastSegment === "-") {
      current.push(value);
    } else {
      const index = parseInt(lastSegment, 10);
      current[index] = value;
    }
  } else {
    current[lastSegment] = value;
  }
}
function addByPath(obj, path, value) {
  const segments = parseJsonPointer(path);
  if (segments.length === 0) return;
  let current = obj;
  for (let i = 0; i < segments.length - 1; i++) {
    const segment = segments[i];
    const nextSegment = segments[i + 1];
    const nextIsNumeric = nextSegment !== void 0 && (isNumericIndex(nextSegment) || nextSegment === "-");
    if (Array.isArray(current)) {
      const index = parseInt(segment, 10);
      if (current[index] === void 0 || typeof current[index] !== "object") {
        current[index] = nextIsNumeric ? [] : {};
      }
      current = current[index];
    } else {
      if (!(segment in current) || typeof current[segment] !== "object") {
        current[segment] = nextIsNumeric ? [] : {};
      }
      current = current[segment];
    }
  }
  const lastSegment = segments[segments.length - 1];
  if (Array.isArray(current)) {
    if (lastSegment === "-") {
      current.push(value);
    } else {
      const index = parseInt(lastSegment, 10);
      current.splice(index, 0, value);
    }
  } else {
    current[lastSegment] = value;
  }
}
function removeByPath(obj, path) {
  const segments = parseJsonPointer(path);
  if (segments.length === 0) return;
  let current = obj;
  for (let i = 0; i < segments.length - 1; i++) {
    const segment = segments[i];
    if (Array.isArray(current)) {
      const index = parseInt(segment, 10);
      if (current[index] === void 0 || typeof current[index] !== "object") {
        return;
      }
      current = current[index];
    } else {
      if (!(segment in current) || typeof current[segment] !== "object") {
        return;
      }
      current = current[segment];
    }
  }
  const lastSegment = segments[segments.length - 1];
  if (Array.isArray(current)) {
    const index = parseInt(lastSegment, 10);
    if (index >= 0 && index < current.length) {
      current.splice(index, 1);
    }
  } else {
    delete current[lastSegment];
  }
}
function deepEqual(a, b) {
  if (a === b) return true;
  if (a === null || b === null) return false;
  if (typeof a !== typeof b) return false;
  if (typeof a !== "object") return false;
  if (Array.isArray(a)) {
    if (!Array.isArray(b)) return false;
    if (a.length !== b.length) return false;
    return a.every((item, i) => deepEqual(item, b[i]));
  }
  const aObj = a;
  const bObj = b;
  const aKeys = Object.keys(aObj);
  const bKeys = Object.keys(bObj);
  if (aKeys.length !== bKeys.length) return false;
  return aKeys.every((key) => deepEqual(aObj[key], bObj[key]));
}
function findFormValue(fieldName, params, state) {
  if (params?.[fieldName] !== void 0) {
    const val = params[fieldName];
    if (typeof val !== "string" || !val.includes(".")) {
      return val;
    }
  }
  if (params) {
    for (const key of Object.keys(params)) {
      if (key.endsWith(`.${fieldName}`)) {
        const val = params[key];
        if (typeof val !== "string" || !val.includes(".")) {
          return val;
        }
      }
    }
  }
  if (state) {
    for (const key of Object.keys(state)) {
      if (key === fieldName || key.endsWith(`.${fieldName}`)) {
        return state[key];
      }
    }
    const val = getByPath(state, fieldName);
    if (val !== void 0) {
      return val;
    }
  }
  return void 0;
}
function parseSpecStreamLine(line) {
  const trimmed = line.trim();
  if (!trimmed || !trimmed.startsWith("{")) return null;
  try {
    const patch = JSON.parse(trimmed);
    if (patch.op && patch.path !== void 0) {
      return patch;
    }
    return null;
  } catch {
    return null;
  }
}
function applySpecStreamPatch(obj, patch) {
  switch (patch.op) {
    case "add":
      addByPath(obj, patch.path, patch.value);
      break;
    case "replace":
      setByPath(obj, patch.path, patch.value);
      break;
    case "remove":
      removeByPath(obj, patch.path);
      break;
    case "move": {
      if (!patch.from) break;
      const moveValue = getByPath(obj, patch.from);
      removeByPath(obj, patch.from);
      addByPath(obj, patch.path, moveValue);
      break;
    }
    case "copy": {
      if (!patch.from) break;
      const copyValue = getByPath(obj, patch.from);
      addByPath(obj, patch.path, copyValue);
      break;
    }
    case "test": {
      const actual = getByPath(obj, patch.path);
      if (!deepEqual(actual, patch.value)) {
        throw new Error(
          `Test operation failed: value at "${patch.path}" does not match`
        );
      }
      break;
    }
  }
  return obj;
}
function applySpecPatch(spec, patch) {
  applySpecStreamPatch(spec, patch);
  return spec;
}
function nestedToFlat(nested) {
  const elements = {};
  let counter = 0;
  function walk(node) {
    const key = `el-${counter++}`;
    const { type, props, children: rawChildren, ...rest } = node;
    const childKeys = [];
    if (Array.isArray(rawChildren)) {
      for (const child of rawChildren) {
        if (child && typeof child === "object" && "type" in child) {
          childKeys.push(walk(child));
        }
      }
    }
    const element = {
      type: type ?? "unknown",
      props: props ?? {},
      children: childKeys
    };
    for (const [k, v] of Object.entries(rest)) {
      if (k !== "state" && v !== void 0) {
        element[k] = v;
      }
    }
    elements[key] = element;
    return key;
  }
  const root = walk(nested);
  const spec = { root, elements };
  if (nested.state && typeof nested.state === "object" && !Array.isArray(nested.state)) {
    spec.state = nested.state;
  }
  return spec;
}
function compileSpecStream(stream, initial = {}) {
  const lines = stream.split("\n");
  const result = { ...initial };
  for (const line of lines) {
    const patch = parseSpecStreamLine(line);
    if (patch) {
      applySpecStreamPatch(result, patch);
    }
  }
  return result;
}
function createSpecStreamCompiler(initial = {}) {
  let result = { ...initial };
  let buffer = "";
  const appliedPatches = [];
  const processedLines = /* @__PURE__ */ new Set();
  return {
    push(chunk) {
      buffer += chunk;
      const newPatches = [];
      const lines = buffer.split("\n");
      buffer = lines.pop() || "";
      for (const line of lines) {
        const trimmed = line.trim();
        if (!trimmed || processedLines.has(trimmed)) continue;
        processedLines.add(trimmed);
        const patch = parseSpecStreamLine(trimmed);
        if (patch) {
          applySpecStreamPatch(result, patch);
          appliedPatches.push(patch);
          newPatches.push(patch);
        }
      }
      if (newPatches.length > 0) {
        result = { ...result };
      }
      return { result, newPatches };
    },
    getResult() {
      if (buffer.trim()) {
        const patch = parseSpecStreamLine(buffer);
        if (patch && !processedLines.has(buffer.trim())) {
          processedLines.add(buffer.trim());
          applySpecStreamPatch(result, patch);
          appliedPatches.push(patch);
          result = { ...result };
        }
        buffer = "";
      }
      return result;
    },
    getPatches() {
      return [...appliedPatches];
    },
    reset(newInitial = {}) {
      result = { ...newInitial };
      buffer = "";
      appliedPatches.length = 0;
      processedLines.clear();
    }
  };
}
function createMixedStreamParser(callbacks) {
  let buffer = "";
  let inSpecFence = false;
  function processLine(line) {
    const trimmed = line.trim();
    if (!inSpecFence && trimmed.startsWith("```spec")) {
      inSpecFence = true;
      return;
    }
    if (inSpecFence && trimmed === "```") {
      inSpecFence = false;
      return;
    }
    if (!trimmed) return;
    if (inSpecFence) {
      const patch2 = parseSpecStreamLine(trimmed);
      if (patch2) {
        callbacks.onPatch(patch2);
      }
      return;
    }
    const patch = parseSpecStreamLine(trimmed);
    if (patch) {
      callbacks.onPatch(patch);
    } else {
      callbacks.onText(line);
    }
  }
  return {
    push(chunk) {
      buffer += chunk;
      const lines = buffer.split("\n");
      buffer = lines.pop() || "";
      for (const line of lines) {
        processLine(line);
      }
    },
    flush() {
      if (buffer.trim()) {
        processLine(buffer);
      }
      buffer = "";
    }
  };
}
var SPEC_FENCE_OPEN = "```spec";
var SPEC_FENCE_CLOSE = "```";
function createJsonRenderTransform() {
  let lineBuffer = "";
  let currentTextId = "";
  let buffering = false;
  let inSpecFence = false;
  function emitPatch(patch, controller) {
    controller.enqueue({
      type: SPEC_DATA_PART_TYPE,
      data: { type: "patch", patch }
    });
  }
  function flushBuffer(controller) {
    if (!lineBuffer) return;
    const trimmed = lineBuffer.trim();
    if (inSpecFence) {
      if (trimmed) {
        const patch = parseSpecStreamLine(trimmed);
        if (patch) emitPatch(patch, controller);
      }
      lineBuffer = "";
      buffering = false;
      return;
    }
    if (trimmed) {
      const patch = parseSpecStreamLine(trimmed);
      if (patch) {
        emitPatch(patch, controller);
      } else {
        controller.enqueue({
          type: "text-delta",
          id: currentTextId,
          delta: lineBuffer
        });
      }
    } else {
      controller.enqueue({
        type: "text-delta",
        id: currentTextId,
        delta: lineBuffer
      });
    }
    lineBuffer = "";
    buffering = false;
  }
  function processCompleteLine(line, controller) {
    const trimmed = line.trim();
    if (!inSpecFence && trimmed.startsWith(SPEC_FENCE_OPEN)) {
      inSpecFence = true;
      return;
    }
    if (inSpecFence && trimmed === SPEC_FENCE_CLOSE) {
      inSpecFence = false;
      return;
    }
    if (inSpecFence) {
      if (trimmed) {
        const patch2 = parseSpecStreamLine(trimmed);
        if (patch2) emitPatch(patch2, controller);
      }
      return;
    }
    if (!trimmed) {
      controller.enqueue({
        type: "text-delta",
        id: currentTextId,
        delta: "\n"
      });
      return;
    }
    const patch = parseSpecStreamLine(trimmed);
    if (patch) {
      emitPatch(patch, controller);
    } else {
      controller.enqueue({
        type: "text-delta",
        id: currentTextId,
        delta: line + "\n"
      });
    }
  }
  return new TransformStream({
    transform(chunk, controller) {
      switch (chunk.type) {
        case "text-start": {
          currentTextId = chunk.id;
          controller.enqueue(chunk);
          break;
        }
        case "text-delta": {
          const delta = chunk;
          currentTextId = delta.id;
          const text = delta.delta;
          for (let i = 0; i < text.length; i++) {
            const ch = text.charAt(i);
            if (ch === "\n") {
              if (buffering) {
                processCompleteLine(lineBuffer, controller);
                lineBuffer = "";
                buffering = false;
              } else {
                if (!inSpecFence) {
                  controller.enqueue({
                    type: "text-delta",
                    id: currentTextId,
                    delta: "\n"
                  });
                }
              }
            } else if (lineBuffer.length === 0 && !buffering) {
              if (inSpecFence || ch === "{" || ch === "`") {
                buffering = true;
                lineBuffer += ch;
              } else {
                controller.enqueue({
                  type: "text-delta",
                  id: currentTextId,
                  delta: ch
                });
              }
            } else if (buffering) {
              lineBuffer += ch;
            } else {
              controller.enqueue({
                type: "text-delta",
                id: currentTextId,
                delta: ch
              });
            }
          }
          break;
        }
        case "text-end": {
          flushBuffer(controller);
          controller.enqueue(chunk);
          break;
        }
        default: {
          controller.enqueue(chunk);
          break;
        }
      }
    },
    flush(controller) {
      flushBuffer(controller);
    }
  });
}
var SPEC_DATA_PART = "spec";
var SPEC_DATA_PART_TYPE = `data-${SPEC_DATA_PART}`;
function pipeJsonRender(stream) {
  return stream.pipeThrough(
    createJsonRenderTransform()
  );
}

// src/visibility.ts
import { z as z2 } from "zod";
var numericOrStateRef = z2.union([
  z2.number(),
  z2.object({ $state: z2.string() })
]);
var comparisonOps = {
  eq: z2.unknown().optional(),
  neq: z2.unknown().optional(),
  gt: numericOrStateRef.optional(),
  gte: numericOrStateRef.optional(),
  lt: numericOrStateRef.optional(),
  lte: numericOrStateRef.optional(),
  not: z2.literal(true).optional()
};
var StateConditionSchema = z2.object({
  $state: z2.string(),
  ...comparisonOps
});
var ItemConditionSchema = z2.object({
  $item: z2.string(),
  ...comparisonOps
});
var IndexConditionSchema = z2.object({
  $index: z2.literal(true),
  ...comparisonOps
});
var SingleConditionSchema = z2.union([
  StateConditionSchema,
  ItemConditionSchema,
  IndexConditionSchema
]);
var VisibilityConditionSchema = z2.lazy(
  () => z2.union([
    z2.boolean(),
    SingleConditionSchema,
    z2.array(SingleConditionSchema),
    z2.object({ $and: z2.array(VisibilityConditionSchema) }),
    z2.object({ $or: z2.array(VisibilityConditionSchema) })
  ])
);
function resolveComparisonValue(value, ctx) {
  if (typeof value === "object" && value !== null) {
    if ("$state" in value && typeof value.$state === "string") {
      return getByPath(ctx.stateModel, value.$state);
    }
  }
  return value;
}
function isItemCondition(cond) {
  return "$item" in cond;
}
function isIndexCondition(cond) {
  return "$index" in cond;
}
function resolveConditionValue(cond, ctx) {
  if (isIndexCondition(cond)) {
    return ctx.repeatIndex;
  }
  if (isItemCondition(cond)) {
    if (ctx.repeatItem === void 0) return void 0;
    return cond.$item === "" ? ctx.repeatItem : getByPath(ctx.repeatItem, cond.$item);
  }
  return getByPath(ctx.stateModel, cond.$state);
}
function evaluateCondition(cond, ctx) {
  const value = resolveConditionValue(cond, ctx);
  let result;
  if (cond.eq !== void 0) {
    const rhs = resolveComparisonValue(cond.eq, ctx);
    result = value === rhs;
  } else if (cond.neq !== void 0) {
    const rhs = resolveComparisonValue(cond.neq, ctx);
    result = value !== rhs;
  } else if (cond.gt !== void 0) {
    const rhs = resolveComparisonValue(cond.gt, ctx);
    result = typeof value === "number" && typeof rhs === "number" ? value > rhs : false;
  } else if (cond.gte !== void 0) {
    const rhs = resolveComparisonValue(cond.gte, ctx);
    result = typeof value === "number" && typeof rhs === "number" ? value >= rhs : false;
  } else if (cond.lt !== void 0) {
    const rhs = resolveComparisonValue(cond.lt, ctx);
    result = typeof value === "number" && typeof rhs === "number" ? value < rhs : false;
  } else if (cond.lte !== void 0) {
    const rhs = resolveComparisonValue(cond.lte, ctx);
    result = typeof value === "number" && typeof rhs === "number" ? value <= rhs : false;
  } else {
    result = Boolean(value);
  }
  return cond.not === true ? !result : result;
}
function isAndCondition(condition) {
  return typeof condition === "object" && condition !== null && !Array.isArray(condition) && "$and" in condition;
}
function isOrCondition(condition) {
  return typeof condition === "object" && condition !== null && !Array.isArray(condition) && "$or" in condition;
}
function evaluateVisibility(condition, ctx) {
  if (condition === void 0) {
    return true;
  }
  if (typeof condition === "boolean") {
    return condition;
  }
  if (Array.isArray(condition)) {
    return condition.every((c) => evaluateCondition(c, ctx));
  }
  if (isAndCondition(condition)) {
    return condition.$and.every((child) => evaluateVisibility(child, ctx));
  }
  if (isOrCondition(condition)) {
    return condition.$or.some((child) => evaluateVisibility(child, ctx));
  }
  return evaluateCondition(condition, ctx);
}
var visibility = {
  /** Always visible */
  always: true,
  /** Never visible */
  never: false,
  /** Visible when state path is truthy */
  when: (path) => ({ $state: path }),
  /** Visible when state path is falsy */
  unless: (path) => ({ $state: path, not: true }),
  /** Equality check */
  eq: (path, value) => ({
    $state: path,
    eq: value
  }),
  /** Not equal check */
  neq: (path, value) => ({
    $state: path,
    neq: value
  }),
  /** Greater than */
  gt: (path, value) => ({
    $state: path,
    gt: value
  }),
  /** Greater than or equal */
  gte: (path, value) => ({
    $state: path,
    gte: value
  }),
  /** Less than */
  lt: (path, value) => ({
    $state: path,
    lt: value
  }),
  /** Less than or equal */
  lte: (path, value) => ({
    $state: path,
    lte: value
  }),
  /** AND multiple conditions */
  and: (...conditions) => ({
    $and: conditions
  }),
  /** OR multiple conditions */
  or: (...conditions) => ({
    $or: conditions
  })
};

// src/props.ts
function isStateExpression(value) {
  return typeof value === "object" && value !== null && "$state" in value && typeof value.$state === "string";
}
function isItemExpression(value) {
  return typeof value === "object" && value !== null && "$item" in value && typeof value.$item === "string";
}
function isIndexExpression(value) {
  return typeof value === "object" && value !== null && "$index" in value && value.$index === true;
}
function isBindStateExpression(value) {
  return typeof value === "object" && value !== null && "$bindState" in value && typeof value.$bindState === "string";
}
function isBindItemExpression(value) {
  return typeof value === "object" && value !== null && "$bindItem" in value && typeof value.$bindItem === "string";
}
function isCondExpression(value) {
  return typeof value === "object" && value !== null && "$cond" in value && "$then" in value && "$else" in value;
}
function resolveBindItemPath(itemPath, ctx) {
  if (ctx.repeatBasePath == null) {
    console.warn(`$bindItem used outside repeat scope: "${itemPath}"`);
    return void 0;
  }
  if (itemPath === "") return ctx.repeatBasePath;
  return ctx.repeatBasePath + "/" + itemPath;
}
function resolvePropValue(value, ctx) {
  if (value === null || value === void 0) {
    return value;
  }
  if (isStateExpression(value)) {
    return getByPath(ctx.stateModel, value.$state);
  }
  if (isItemExpression(value)) {
    if (ctx.repeatItem === void 0) return void 0;
    return value.$item === "" ? ctx.repeatItem : getByPath(ctx.repeatItem, value.$item);
  }
  if (isIndexExpression(value)) {
    return ctx.repeatIndex;
  }
  if (isBindStateExpression(value)) {
    return getByPath(ctx.stateModel, value.$bindState);
  }
  if (isBindItemExpression(value)) {
    const resolvedPath = resolveBindItemPath(value.$bindItem, ctx);
    if (resolvedPath === void 0) return void 0;
    return getByPath(ctx.stateModel, resolvedPath);
  }
  if (isCondExpression(value)) {
    const result = evaluateVisibility(value.$cond, ctx);
    return resolvePropValue(result ? value.$then : value.$else, ctx);
  }
  if (Array.isArray(value)) {
    return value.map((item) => resolvePropValue(item, ctx));
  }
  if (typeof value === "object") {
    const resolved = {};
    for (const [key, val] of Object.entries(value)) {
      resolved[key] = resolvePropValue(val, ctx);
    }
    return resolved;
  }
  return value;
}
function resolveElementProps(props, ctx) {
  const resolved = {};
  for (const [key, value] of Object.entries(props)) {
    resolved[key] = resolvePropValue(value, ctx);
  }
  return resolved;
}
function resolveBindings(props, ctx) {
  let bindings;
  for (const [key, value] of Object.entries(props)) {
    if (isBindStateExpression(value)) {
      if (!bindings) bindings = {};
      bindings[key] = value.$bindState;
    } else if (isBindItemExpression(value)) {
      const resolved = resolveBindItemPath(value.$bindItem, ctx);
      if (resolved !== void 0) {
        if (!bindings) bindings = {};
        bindings[key] = resolved;
      }
    }
  }
  return bindings;
}
function resolveActionParam(value, ctx) {
  if (isItemExpression(value)) {
    return resolveBindItemPath(value.$item, ctx);
  }
  if (isIndexExpression(value)) {
    return ctx.repeatIndex;
  }
  return resolvePropValue(value, ctx);
}

// src/actions.ts
import { z as z3 } from "zod";
var ActionConfirmSchema = z3.object({
  title: z3.string(),
  message: z3.string(),
  confirmLabel: z3.string().optional(),
  cancelLabel: z3.string().optional(),
  variant: z3.enum(["default", "danger"]).optional()
});
var ActionOnSuccessSchema = z3.union([
  z3.object({ navigate: z3.string() }),
  z3.object({ set: z3.record(z3.string(), z3.unknown()) }),
  z3.object({ action: z3.string() })
]);
var ActionOnErrorSchema = z3.union([
  z3.object({ set: z3.record(z3.string(), z3.unknown()) }),
  z3.object({ action: z3.string() })
]);
var ActionBindingSchema = z3.object({
  action: z3.string(),
  params: z3.record(z3.string(), DynamicValueSchema).optional(),
  confirm: ActionConfirmSchema.optional(),
  onSuccess: ActionOnSuccessSchema.optional(),
  onError: ActionOnErrorSchema.optional()
});
var ActionSchema = ActionBindingSchema;
function resolveAction(binding, stateModel) {
  const resolvedParams = {};
  if (binding.params) {
    for (const [key, value] of Object.entries(binding.params)) {
      resolvedParams[key] = resolveDynamicValue(value, stateModel);
    }
  }
  let confirm = binding.confirm;
  if (confirm) {
    confirm = {
      ...confirm,
      message: interpolateString(confirm.message, stateModel),
      title: interpolateString(confirm.title, stateModel)
    };
  }
  return {
    action: binding.action,
    params: resolvedParams,
    confirm,
    onSuccess: binding.onSuccess,
    onError: binding.onError
  };
}
function interpolateString(template, stateModel) {
  return template.replace(/\$\{([^}]+)\}/g, (_, path) => {
    const value = resolveDynamicValue({ $state: path }, stateModel);
    return String(value ?? "");
  });
}
async function executeAction(ctx) {
  const { action: action2, handler, setState, navigate, executeAction: executeAction2 } = ctx;
  try {
    await handler(action2.params);
    if (action2.onSuccess) {
      if ("navigate" in action2.onSuccess && navigate) {
        navigate(action2.onSuccess.navigate);
      } else if ("set" in action2.onSuccess) {
        for (const [path, value] of Object.entries(action2.onSuccess.set)) {
          setState(path, value);
        }
      } else if ("action" in action2.onSuccess && executeAction2) {
        await executeAction2(action2.onSuccess.action);
      }
    }
  } catch (error) {
    if (action2.onError) {
      if ("set" in action2.onError) {
        for (const [path, value] of Object.entries(action2.onError.set)) {
          const resolvedValue = typeof value === "string" && value === "$error.message" ? error.message : value;
          setState(path, resolvedValue);
        }
      } else if ("action" in action2.onError && executeAction2) {
        await executeAction2(action2.onError.action);
      }
    } else {
      throw error;
    }
  }
}
var actionBinding = {
  /** Create a simple action binding */
  simple: (actionName, params) => ({
    action: actionName,
    params
  }),
  /** Create an action binding with confirmation */
  withConfirm: (actionName, confirm, params) => ({
    action: actionName,
    params,
    confirm
  }),
  /** Create an action binding with success handler */
  withSuccess: (actionName, onSuccess, params) => ({
    action: actionName,
    params,
    onSuccess
  })
};
var action = actionBinding;

// src/validation.ts
import { z as z4 } from "zod";
var ValidationCheckSchema = z4.object({
  type: z4.string(),
  args: z4.record(z4.string(), DynamicValueSchema).optional(),
  message: z4.string()
});
var ValidationConfigSchema = z4.object({
  checks: z4.array(ValidationCheckSchema).optional(),
  validateOn: z4.enum(["change", "blur", "submit"]).optional(),
  enabled: VisibilityConditionSchema.optional()
});
var builtInValidationFunctions = {
  /**
   * Check if value is not null, undefined, or empty string
   */
  required: (value) => {
    if (value === null || value === void 0) return false;
    if (typeof value === "string") return value.trim().length > 0;
    if (Array.isArray(value)) return value.length > 0;
    return true;
  },
  /**
   * Check if value is a valid email address
   */
  email: (value) => {
    if (typeof value !== "string") return false;
    return /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(value);
  },
  /**
   * Check minimum string length
   */
  minLength: (value, args) => {
    if (typeof value !== "string") return false;
    const min = args?.min;
    if (typeof min !== "number") return false;
    return value.length >= min;
  },
  /**
   * Check maximum string length
   */
  maxLength: (value, args) => {
    if (typeof value !== "string") return false;
    const max = args?.max;
    if (typeof max !== "number") return false;
    return value.length <= max;
  },
  /**
   * Check if string matches a regex pattern
   */
  pattern: (value, args) => {
    if (typeof value !== "string") return false;
    const pattern = args?.pattern;
    if (typeof pattern !== "string") return false;
    try {
      return new RegExp(pattern).test(value);
    } catch {
      return false;
    }
  },
  /**
   * Check minimum numeric value
   */
  min: (value, args) => {
    if (typeof value !== "number") return false;
    const min = args?.min;
    if (typeof min !== "number") return false;
    return value >= min;
  },
  /**
   * Check maximum numeric value
   */
  max: (value, args) => {
    if (typeof value !== "number") return false;
    const max = args?.max;
    if (typeof max !== "number") return false;
    return value <= max;
  },
  /**
   * Check if value is a number
   */
  numeric: (value) => {
    if (typeof value === "number") return !isNaN(value);
    if (typeof value === "string") return !isNaN(parseFloat(value));
    return false;
  },
  /**
   * Check if value is a valid URL
   */
  url: (value) => {
    if (typeof value !== "string") return false;
    try {
      new URL(value);
      return true;
    } catch {
      return false;
    }
  },
  /**
   * Check if value matches another field
   */
  matches: (value, args) => {
    const other = args?.other;
    return value === other;
  }
};
function runValidationCheck(check2, ctx) {
  const { value, stateModel, customFunctions } = ctx;
  const resolvedArgs = {};
  if (check2.args) {
    for (const [key, argValue] of Object.entries(check2.args)) {
      resolvedArgs[key] = resolveDynamicValue(argValue, stateModel);
    }
  }
  const validationFn = builtInValidationFunctions[check2.type] ?? customFunctions?.[check2.type];
  if (!validationFn) {
    console.warn(`Unknown validation function: ${check2.type}`);
    return {
      type: check2.type,
      valid: true,
      // Don't fail on unknown functions
      message: check2.message
    };
  }
  const valid = validationFn(value, resolvedArgs);
  return {
    type: check2.type,
    valid,
    message: check2.message
  };
}
function runValidation(config, ctx) {
  const checks = [];
  const errors = [];
  if (config.enabled) {
    const enabled = evaluateVisibility(config.enabled, {
      stateModel: ctx.stateModel
    });
    if (!enabled) {
      return { valid: true, errors: [], checks: [] };
    }
  }
  if (config.checks) {
    for (const check2 of config.checks) {
      const result = runValidationCheck(check2, ctx);
      checks.push(result);
      if (!result.valid) {
        errors.push(result.message);
      }
    }
  }
  return {
    valid: errors.length === 0,
    errors,
    checks
  };
}
var check = {
  required: (message = "This field is required") => ({
    type: "required",
    message
  }),
  email: (message = "Invalid email address") => ({
    type: "email",
    message
  }),
  minLength: (min, message) => ({
    type: "minLength",
    args: { min },
    message: message ?? `Must be at least ${min} characters`
  }),
  maxLength: (max, message) => ({
    type: "maxLength",
    args: { max },
    message: message ?? `Must be at most ${max} characters`
  }),
  pattern: (pattern, message = "Invalid format") => ({
    type: "pattern",
    args: { pattern },
    message
  }),
  min: (min, message) => ({
    type: "min",
    args: { min },
    message: message ?? `Must be at least ${min}`
  }),
  max: (max, message) => ({
    type: "max",
    args: { max },
    message: message ?? `Must be at most ${max}`
  }),
  url: (message = "Invalid URL") => ({
    type: "url",
    message
  }),
  matches: (otherPath, message = "Fields must match") => ({
    type: "matches",
    args: { other: { $state: otherPath } },
    message
  })
};

// src/spec-validator.ts
function validateSpec(spec, options = {}) {
  const { checkOrphans = false } = options;
  const issues = [];
  if (!spec.root) {
    issues.push({
      severity: "error",
      message: "Spec has no root element defined.",
      code: "missing_root"
    });
    return { valid: false, issues };
  }
  if (!spec.elements[spec.root]) {
    issues.push({
      severity: "error",
      message: `Root element "${spec.root}" not found in elements map.`,
      code: "root_not_found"
    });
  }
  if (Object.keys(spec.elements).length === 0) {
    issues.push({
      severity: "error",
      message: "Spec has no elements.",
      code: "empty_spec"
    });
    return { valid: false, issues };
  }
  for (const [key, element] of Object.entries(spec.elements)) {
    if (element.children) {
      for (const childKey of element.children) {
        if (!spec.elements[childKey]) {
          issues.push({
            severity: "error",
            message: `Element "${key}" references child "${childKey}" which does not exist in the elements map.`,
            elementKey: key,
            code: "missing_child"
          });
        }
      }
    }
    const props = element.props;
    if (props && "visible" in props && props.visible !== void 0) {
      issues.push({
        severity: "error",
        message: `Element "${key}" has "visible" inside "props". It should be a top-level field on the element (sibling of type/props/children).`,
        elementKey: key,
        code: "visible_in_props"
      });
    }
    if (props && "on" in props && props.on !== void 0) {
      issues.push({
        severity: "error",
        message: `Element "${key}" has "on" inside "props". It should be a top-level field on the element (sibling of type/props/children).`,
        elementKey: key,
        code: "on_in_props"
      });
    }
    if (props && "repeat" in props && props.repeat !== void 0) {
      issues.push({
        severity: "error",
        message: `Element "${key}" has "repeat" inside "props". It should be a top-level field on the element (sibling of type/props/children).`,
        elementKey: key,
        code: "repeat_in_props"
      });
    }
  }
  if (checkOrphans) {
    const reachable = /* @__PURE__ */ new Set();
    const walk = (key) => {
      if (reachable.has(key)) return;
      reachable.add(key);
      const el = spec.elements[key];
      if (el?.children) {
        for (const childKey of el.children) {
          if (spec.elements[childKey]) {
            walk(childKey);
          }
        }
      }
    };
    if (spec.elements[spec.root]) {
      walk(spec.root);
    }
    for (const key of Object.keys(spec.elements)) {
      if (!reachable.has(key)) {
        issues.push({
          severity: "warning",
          message: `Element "${key}" is not reachable from root "${spec.root}".`,
          elementKey: key,
          code: "orphaned_element"
        });
      }
    }
  }
  const hasErrors = issues.some((i) => i.severity === "error");
  return { valid: !hasErrors, issues };
}
function autoFixSpec(spec) {
  const fixes = [];
  const fixedElements = {};
  for (const [key, element] of Object.entries(spec.elements)) {
    const props = element.props;
    let fixed = element;
    if (props && "visible" in props && props.visible !== void 0) {
      const { visible, ...restProps } = fixed.props;
      fixed = {
        ...fixed,
        props: restProps,
        visible
      };
      fixes.push(`Moved "visible" from props to element level on "${key}".`);
    }
    let currentProps = fixed.props;
    if (currentProps && "on" in currentProps && currentProps.on !== void 0) {
      const { on, ...restProps } = currentProps;
      fixed = {
        ...fixed,
        props: restProps,
        on
      };
      fixes.push(`Moved "on" from props to element level on "${key}".`);
    }
    currentProps = fixed.props;
    if (currentProps && "repeat" in currentProps && currentProps.repeat !== void 0) {
      const { repeat, ...restProps } = currentProps;
      fixed = {
        ...fixed,
        props: restProps,
        repeat
      };
      fixes.push(`Moved "repeat" from props to element level on "${key}".`);
    }
    fixedElements[key] = fixed;
  }
  return {
    spec: { root: spec.root, elements: fixedElements, state: spec.state },
    fixes
  };
}
function formatSpecIssues(issues) {
  const errors = issues.filter((i) => i.severity === "error");
  if (errors.length === 0) return "";
  const lines = ["The generated UI spec has the following errors:"];
  for (const issue of errors) {
    lines.push(`- ${issue.message}`);
  }
  return lines.join("\n");
}

// src/schema.ts
import { z as z5 } from "zod";
function createBuilder() {
  return {
    string: () => ({ kind: "string" }),
    number: () => ({ kind: "number" }),
    boolean: () => ({ kind: "boolean" }),
    array: (item) => ({ kind: "array", inner: item }),
    object: (shape) => ({ kind: "object", inner: shape }),
    record: (value) => ({ kind: "record", inner: value }),
    any: () => ({ kind: "any" }),
    zod: () => ({ kind: "zod" }),
    ref: (path) => ({ kind: "ref", inner: path }),
    propsOf: (path) => ({ kind: "propsOf", inner: path }),
    map: (entryShape) => ({ kind: "map", inner: entryShape }),
    optional: () => ({ optional: true })
  };
}
function defineSchema(builder, options) {
  const s = createBuilder();
  const definition = builder(s);
  return {
    definition,
    promptTemplate: options?.promptTemplate,
    defaultRules: options?.defaultRules,
    createCatalog(catalog) {
      return createCatalogFromSchema(this, catalog);
    }
  };
}
function createCatalogFromSchema(schema, catalogData) {
  const components = catalogData.components;
  const actions = catalogData.actions;
  const componentNames = components ? Object.keys(components) : [];
  const actionNames = actions ? Object.keys(actions) : [];
  const zodSchema = buildZodSchemaFromDefinition(
    schema.definition,
    catalogData
  );
  return {
    schema,
    data: catalogData,
    componentNames,
    actionNames,
    prompt(options = {}) {
      return generatePrompt(this, options);
    },
    jsonSchema() {
      return zodToJsonSchema(zodSchema);
    },
    validate(spec) {
      const result = zodSchema.safeParse(spec);
      if (result.success) {
        return {
          success: true,
          data: result.data
        };
      }
      return { success: false, error: result.error };
    },
    zodSchema() {
      return zodSchema;
    },
    get _specType() {
      throw new Error("_specType is only for type inference");
    }
  };
}
function buildZodSchemaFromDefinition(definition, catalogData) {
  return buildZodType(definition.spec, catalogData);
}
function buildZodType(schemaType, catalogData) {
  switch (schemaType.kind) {
    case "string":
      return z5.string();
    case "number":
      return z5.number();
    case "boolean":
      return z5.boolean();
    case "any":
      return z5.any();
    case "array": {
      const inner = buildZodType(schemaType.inner, catalogData);
      return z5.array(inner);
    }
    case "object": {
      const shape = schemaType.inner;
      const zodShape = {};
      for (const [key, value] of Object.entries(shape)) {
        let zodType = buildZodType(value, catalogData);
        if (value.optional) {
          zodType = zodType.optional();
        }
        zodShape[key] = zodType;
      }
      return z5.object(zodShape);
    }
    case "record": {
      const inner = buildZodType(schemaType.inner, catalogData);
      return z5.record(z5.string(), inner);
    }
    case "ref": {
      const path = schemaType.inner;
      const keys = getKeysFromPath(path, catalogData);
      if (keys.length === 0) {
        return z5.string();
      }
      if (keys.length === 1) {
        return z5.literal(keys[0]);
      }
      return z5.enum(keys);
    }
    case "propsOf": {
      const path = schemaType.inner;
      const propsSchemas = getPropsFromPath(path, catalogData);
      if (propsSchemas.length === 0) {
        return z5.record(z5.string(), z5.unknown());
      }
      if (propsSchemas.length === 1) {
        return propsSchemas[0];
      }
      return z5.record(z5.string(), z5.unknown());
    }
    default:
      return z5.unknown();
  }
}
function getKeysFromPath(path, catalogData) {
  const parts = path.split(".");
  let current = { catalog: catalogData };
  for (const part of parts) {
    if (current && typeof current === "object") {
      current = current[part];
    } else {
      return [];
    }
  }
  if (current && typeof current === "object") {
    return Object.keys(current);
  }
  return [];
}
function getPropsFromPath(path, catalogData) {
  const parts = path.split(".");
  let current = { catalog: catalogData };
  for (const part of parts) {
    if (current && typeof current === "object") {
      current = current[part];
    } else {
      return [];
    }
  }
  if (current && typeof current === "object") {
    return Object.values(current).map((entry) => entry.props).filter((props) => props !== void 0);
  }
  return [];
}
function generatePrompt(catalog, options) {
  if (catalog.schema.promptTemplate) {
    const context = {
      catalog: catalog.data,
      componentNames: catalog.componentNames,
      actionNames: catalog.actionNames,
      options,
      formatZodType
    };
    return catalog.schema.promptTemplate(context);
  }
  const {
    system = "You are a UI generator that outputs JSON.",
    customRules = [],
    mode = "generate"
  } = options;
  const lines = [];
  lines.push(system);
  lines.push("");
  if (mode === "chat") {
    lines.push("OUTPUT FORMAT (text + JSONL, RFC 6902 JSON Patch):");
    lines.push(
      "You respond conversationally. When generating UI, first write a brief explanation (1-3 sentences), then output JSONL patch lines wrapped in a ```spec code fence."
    );
    lines.push(
      "The JSONL lines use RFC 6902 JSON Patch operations to build a UI tree. Always wrap them in a ```spec fence block:"
    );
    lines.push("  ```spec");
    lines.push('  {"op":"add","path":"/root","value":"main"}');
    lines.push(
      '  {"op":"add","path":"/elements/main","value":{"type":"Card","props":{"title":"Hello"},"children":[]}}'
    );
    lines.push("  ```");
    lines.push(
      "If the user's message does not require a UI (e.g. a greeting or clarifying question), respond with text only \u2014 no JSONL."
    );
  } else {
    lines.push("OUTPUT FORMAT (JSONL, RFC 6902 JSON Patch):");
    lines.push(
      "Output JSONL (one JSON object per line) using RFC 6902 JSON Patch operations to build a UI tree."
    );
  }
  lines.push(
    "Each line is a JSON patch operation (add, remove, replace). Start with /root, then stream /elements and /state patches interleaved so the UI fills in progressively as it streams."
  );
  lines.push("");
  lines.push("Example output (each line is a separate JSON object):");
  lines.push("");
  const allComponents = catalog.data.components;
  const cn = catalog.componentNames;
  const comp1 = cn[0] || "Component";
  const comp2 = cn.length > 1 ? cn[1] : comp1;
  const comp1Def = allComponents?.[comp1];
  const comp2Def = allComponents?.[comp2];
  const comp1Props = comp1Def ? getExampleProps(comp1Def) : {};
  const comp2Props = comp2Def ? getExampleProps(comp2Def) : {};
  const dynamicPropName = comp2Def?.props ? findFirstStringProp(comp2Def.props) : null;
  const dynamicProps = dynamicPropName ? { ...comp2Props, [dynamicPropName]: { $item: "title" } } : comp2Props;
  const exampleOutput = [
    JSON.stringify({ op: "add", path: "/root", value: "main" }),
    JSON.stringify({
      op: "add",
      path: "/elements/main",
      value: {
        type: comp1,
        props: comp1Props,
        children: ["child-1", "list"]
      }
    }),
    JSON.stringify({
      op: "add",
      path: "/elements/child-1",
      value: { type: comp2, props: comp2Props, children: [] }
    }),
    JSON.stringify({
      op: "add",
      path: "/elements/list",
      value: {
        type: comp1,
        props: comp1Props,
        repeat: { statePath: "/items", key: "id" },
        children: ["item"]
      }
    }),
    JSON.stringify({
      op: "add",
      path: "/elements/item",
      value: { type: comp2, props: dynamicProps, children: [] }
    }),
    JSON.stringify({ op: "add", path: "/state/items", value: [] }),
    JSON.stringify({
      op: "add",
      path: "/state/items/0",
      value: { id: "1", title: "First Item" }
    }),
    JSON.stringify({
      op: "add",
      path: "/state/items/1",
      value: { id: "2", title: "Second Item" }
    })
  ].join("\n");
  lines.push(`${exampleOutput}

Note: state patches appear right after the elements that use them, so the UI fills in as it streams. ONLY use component types from the AVAILABLE COMPONENTS list below.`);
  lines.push("");
  lines.push("INITIAL STATE:");
  lines.push(
    "Specs include a /state field to seed the state model. Components with { $bindState } or { $bindItem } read from and write to this state, and $state expressions read from it."
  );
  lines.push(
    "CRITICAL: You MUST include state patches whenever your UI displays data via $state, $bindState, $bindItem, $item, or $index expressions, or uses repeat to iterate over arrays. Without state, these references resolve to nothing and repeat lists render zero items."
  );
  lines.push(
    "Output state patches right after the elements that reference them, so the UI fills in progressively as it streams."
  );
  lines.push(
    "Stream state progressively - output one patch per array item instead of one giant blob:"
  );
  lines.push(
    '  For arrays: {"op":"add","path":"/state/posts/0","value":{"id":"1","title":"First Post",...}} then /state/posts/1, /state/posts/2, etc.'
  );
  lines.push(
    '  For scalars: {"op":"add","path":"/state/newTodoText","value":""}'
  );
  lines.push(
    '  Initialize the array first if needed: {"op":"add","path":"/state/posts","value":[]}'
  );
  lines.push(
    'When content comes from the state model, use { "$state": "/some/path" } dynamic props to display it instead of hardcoding the same value in both state and props. The state model is the single source of truth.'
  );
  lines.push(
    "Include realistic sample data in state. For blogs: 3-4 posts with titles, excerpts, authors, dates. For product lists: 3-5 items with names, prices, descriptions. Never leave arrays empty."
  );
  lines.push("");
  lines.push("DYNAMIC LISTS (repeat field):");
  lines.push(
    'Any element can have a top-level "repeat" field to render its children once per item in a state array: { "repeat": { "statePath": "/arrayPath", "key": "id" } }.'
  );
  lines.push(
    'The element itself renders once (as the container), and its children are expanded once per array item. "statePath" is the state array path. "key" is an optional field name on each item for stable React keys.'
  );
  lines.push(
    `Example: ${JSON.stringify({ type: comp1, props: comp1Props, repeat: { statePath: "/todos", key: "id" }, children: ["todo-item"] })}`
  );
  lines.push(
    'Inside children of a repeated element, use { "$item": "field" } to read a field from the current item, and { "$index": true } to get the current array index. For two-way binding to an item field use { "$bindItem": "completed" } on the appropriate prop.'
  );
  lines.push(
    "ALWAYS use the repeat field for lists backed by state arrays. NEVER hardcode individual elements for each array item."
  );
  lines.push(
    'IMPORTANT: "repeat" is a top-level field on the element (sibling of type/props/children), NOT inside props.'
  );
  lines.push("");
  lines.push("ARRAY STATE ACTIONS:");
  lines.push(
    'Use action "pushState" to append items to arrays. Params: { statePath: "/arrayPath", value: { ...item }, clearStatePath: "/inputPath" }.'
  );
  lines.push(
    'Values inside pushState can contain { "$state": "/statePath" } references to read current state (e.g. the text from an input field).'
  );
  lines.push(
    'Use "$id" inside a pushState value to auto-generate a unique ID.'
  );
  lines.push(
    'Example: on: { "press": { "action": "pushState", "params": { "statePath": "/todos", "value": { "id": "$id", "title": { "$state": "/newTodoText" }, "completed": false }, "clearStatePath": "/newTodoText" } } }'
  );
  lines.push(
    `Use action "removeState" to remove items from arrays by index. Params: { statePath: "/arrayPath", index: N }. Inside a repeated element's children, use { "$index": true } for the current item index. Action params support the same expressions as props: { "$item": "field" } resolves to the absolute state path, { "$index": true } resolves to the index number, and { "$state": "/path" } reads a value from state.`
  );
  lines.push(
    "For lists where users can add/remove items (todos, carts, etc.), use pushState and removeState instead of hardcoding with setState."
  );
  lines.push("");
  lines.push(
    'IMPORTANT: State paths use RFC 6901 JSON Pointer syntax (e.g. "/todos/0/title"). Do NOT use JavaScript-style dot notation (e.g. "/todos.length" is WRONG). To generate unique IDs for new items, use "$id" instead of trying to read array length.'
  );
  lines.push("");
  const components = allComponents;
  if (components) {
    lines.push(`AVAILABLE COMPONENTS (${catalog.componentNames.length}):`);
    lines.push("");
    for (const [name, def] of Object.entries(components)) {
      const propsStr = def.props ? formatZodType(def.props) : "{}";
      const hasChildren = def.slots && def.slots.length > 0;
      const childrenStr = hasChildren ? " [accepts children]" : "";
      const eventsStr = def.events && def.events.length > 0 ? ` [events: ${def.events.join(", ")}]` : "";
      const descStr = def.description ? ` - ${def.description}` : "";
      lines.push(`- ${name}: ${propsStr}${descStr}${childrenStr}${eventsStr}`);
    }
    lines.push("");
  }
  const actions = catalog.data.actions;
  if (actions && catalog.actionNames.length > 0) {
    lines.push("AVAILABLE ACTIONS:");
    lines.push("");
    for (const [name, def] of Object.entries(actions)) {
      lines.push(`- ${name}${def.description ? `: ${def.description}` : ""}`);
    }
    lines.push("");
  }
  lines.push("EVENTS (the `on` field):");
  lines.push(
    "Elements can have an optional `on` field to bind events to actions. The `on` field is a top-level field on the element (sibling of type/props/children), NOT inside props."
  );
  lines.push(
    'Each key in `on` is an event name (from the component\'s supported events), and the value is an action binding: `{ "action": "<actionName>", "params": { ... } }`.'
  );
  lines.push("");
  lines.push("Example:");
  lines.push(
    `  ${JSON.stringify({ type: comp1, props: comp1Props, on: { press: { action: "setState", params: { statePath: "/saved", value: true } } }, children: [] })}`
  );
  lines.push("");
  lines.push(
    'Action params can use dynamic references to read from state: { "$state": "/statePath" }.'
  );
  lines.push(
    "IMPORTANT: Do NOT put action/actionParams inside props. Always use the `on` field for event bindings."
  );
  lines.push("");
  lines.push("VISIBILITY CONDITIONS:");
  lines.push(
    "Elements can have an optional `visible` field to conditionally show/hide based on state. IMPORTANT: `visible` is a top-level field on the element object (sibling of type/props/children), NOT inside props."
  );
  lines.push(
    `Correct: ${JSON.stringify({ type: comp1, props: comp1Props, visible: { $state: "/activeTab", eq: "home" }, children: ["..."] })}`
  );
  lines.push(
    '- `{ "$state": "/path" }` - visible when state at path is truthy'
  );
  lines.push(
    '- `{ "$state": "/path", "not": true }` - visible when state at path is falsy'
  );
  lines.push(
    '- `{ "$state": "/path", "eq": "value" }` - visible when state equals value'
  );
  lines.push(
    '- `{ "$state": "/path", "neq": "value" }` - visible when state does not equal value'
  );
  lines.push(
    '- `{ "$state": "/path", "gt": N }` / `gte` / `lt` / `lte` - numeric comparisons'
  );
  lines.push(
    "- Use ONE operator per condition (eq, neq, gt, gte, lt, lte). Do not combine multiple operators."
  );
  lines.push('- Any condition can add `"not": true` to invert its result');
  lines.push(
    "- `[condition, condition]` - all conditions must be true (implicit AND)"
  );
  lines.push(
    '- `{ "$and": [condition, condition] }` - explicit AND (use when nesting inside $or)'
  );
  lines.push(
    '- `{ "$or": [condition, condition] }` - at least one must be true (OR)'
  );
  lines.push("- `true` / `false` - always visible/hidden");
  lines.push("");
  lines.push(
    "Use a component with on.press bound to setState to update state and drive visibility."
  );
  lines.push(
    `Example: A ${comp1} with on: { "press": { "action": "setState", "params": { "statePath": "/activeTab", "value": "home" } } } sets state, then a container with visible: { "$state": "/activeTab", "eq": "home" } shows only when that tab is active.`
  );
  lines.push("");
  lines.push(
    'For tab patterns where the first/default tab should be visible when no tab is selected yet, use $or to handle both cases: visible: { "$or": [{ "$state": "/activeTab", "eq": "home" }, { "$state": "/activeTab", "not": true }] }. This ensures the first tab is visible both when explicitly selected AND when /activeTab is not yet set.'
  );
  lines.push("");
  lines.push("DYNAMIC PROPS:");
  lines.push(
    "Any prop value can be a dynamic expression that resolves based on state. Three forms are supported:"
  );
  lines.push("");
  lines.push(
    '1. Read-only state: `{ "$state": "/statePath" }` - resolves to the value at that state path (one-way read).'
  );
  lines.push(
    '   Example: `"color": { "$state": "/theme/primary" }` reads the color from state.'
  );
  lines.push("");
  lines.push(
    '2. Two-way binding: `{ "$bindState": "/statePath" }` - resolves to the value at the state path AND enables write-back. Use on form input props (value, checked, pressed, etc.).'
  );
  lines.push(
    '   Example: `"value": { "$bindState": "/form/email" }` binds the input value to /form/email.'
  );
  lines.push(
    '   Inside repeat scopes: `"checked": { "$bindItem": "completed" }` binds to the current item\'s completed field.'
  );
  lines.push("");
  lines.push(
    '3. Conditional: `{ "$cond": <condition>, "$then": <value>, "$else": <value> }` - evaluates the condition (same syntax as visibility conditions) and picks the matching value.'
  );
  lines.push(
    '   Example: `"color": { "$cond": { "$state": "/activeTab", "eq": "home" }, "$then": "#007AFF", "$else": "#8E8E93" }`'
  );
  lines.push("");
  lines.push(
    "Use $bindState for form inputs (text fields, checkboxes, selects, sliders, etc.) and $state for read-only data display. Inside repeat scopes, use $bindItem for form inputs bound to the current item. Use dynamic props instead of duplicating elements with opposing visible conditions when only prop values differ."
  );
  lines.push("");
  const hasChecksComponents = allComponents ? Object.entries(allComponents).some(([, def]) => {
    if (!def.props) return false;
    const formatted = formatZodType(def.props);
    return formatted.includes("checks");
  }) : false;
  if (hasChecksComponents) {
    lines.push("VALIDATION:");
    lines.push(
      "Form components that accept a `checks` prop support client-side validation."
    );
    lines.push(
      'Each check is an object: { "type": "<name>", "message": "...", "args": { ... } }'
    );
    lines.push("");
    lines.push("Built-in validation types:");
    lines.push("  - required \u2014 value must be non-empty");
    lines.push("  - email \u2014 valid email format");
    lines.push('  - minLength \u2014 minimum string length (args: { "min": N })');
    lines.push('  - maxLength \u2014 maximum string length (args: { "max": N })');
    lines.push('  - pattern \u2014 match a regex (args: { "pattern": "regex" })');
    lines.push('  - min \u2014 minimum numeric value (args: { "min": N })');
    lines.push('  - max \u2014 maximum numeric value (args: { "max": N })');
    lines.push("  - numeric \u2014 value must be a number");
    lines.push("  - url \u2014 valid URL format");
    lines.push(
      '  - matches \u2014 must equal another field (args: { "other": "value" })'
    );
    lines.push("");
    lines.push("Example:");
    lines.push(
      '  "checks": [{ "type": "required", "message": "Email is required" }, { "type": "email", "message": "Invalid email" }]'
    );
    lines.push("");
    lines.push(
      "IMPORTANT: When using checks, the component must also have a { $bindState } or { $bindItem } on its value/checked prop for two-way binding."
    );
    lines.push(
      "Always include validation checks on form inputs for a good user experience (e.g. required, email, minLength)."
    );
    lines.push("");
  }
  lines.push("RULES:");
  const baseRules = mode === "chat" ? [
    "When generating UI, wrap all JSONL patches in a ```spec code fence - one JSON object per line inside the fence",
    "Write a brief conversational response before any JSONL output",
    'First set root: {"op":"add","path":"/root","value":"<root-key>"}',
    'Then add each element: {"op":"add","path":"/elements/<key>","value":{...}}',
    "Output /state patches right after the elements that use them, one per array item for progressive loading. REQUIRED whenever using $state, $bindState, $bindItem, $item, $index, or repeat.",
    "ONLY use components listed above",
    "Each element value needs: type, props, children (array of child keys)",
    "Use unique keys for the element map entries (e.g., 'header', 'metric-1', 'chart-revenue')"
  ] : [
    "Output ONLY JSONL patches - one JSON object per line, no markdown, no code fences",
    'First set root: {"op":"add","path":"/root","value":"<root-key>"}',
    'Then add each element: {"op":"add","path":"/elements/<key>","value":{...}}',
    "Output /state patches right after the elements that use them, one per array item for progressive loading. REQUIRED whenever using $state, $bindState, $bindItem, $item, $index, or repeat.",
    "ONLY use components listed above",
    "Each element value needs: type, props, children (array of child keys)",
    "Use unique keys for the element map entries (e.g., 'header', 'metric-1', 'chart-revenue')"
  ];
  const schemaRules = catalog.schema.defaultRules ?? [];
  const allRules = [...baseRules, ...schemaRules, ...customRules];
  allRules.forEach((rule, i) => {
    lines.push(`${i + 1}. ${rule}`);
  });
  return lines.join("\n");
}
function getExampleProps(def) {
  if (def.example && Object.keys(def.example).length > 0) {
    return def.example;
  }
  if (def.props) {
    return generateExamplePropsFromZod(def.props);
  }
  return {};
}
function generateExamplePropsFromZod(schema) {
  if (!schema || !schema._def) return {};
  const def = schema._def;
  const typeName = getZodTypeName(schema);
  if (typeName !== "ZodObject" && typeName !== "object") return {};
  const shape = typeof def.shape === "function" ? def.shape() : def.shape;
  if (!shape) return {};
  const result = {};
  for (const [key, value] of Object.entries(shape)) {
    const innerTypeName = getZodTypeName(value);
    if (innerTypeName === "ZodOptional" || innerTypeName === "optional" || innerTypeName === "ZodNullable" || innerTypeName === "nullable") {
      continue;
    }
    result[key] = generateExampleValue(value);
  }
  return result;
}
function generateExampleValue(schema) {
  if (!schema || !schema._def) return "...";
  const def = schema._def;
  const typeName = getZodTypeName(schema);
  switch (typeName) {
    case "ZodString":
    case "string":
      return "example";
    case "ZodNumber":
    case "number":
      return 0;
    case "ZodBoolean":
    case "boolean":
      return true;
    case "ZodLiteral":
    case "literal":
      return def.value;
    case "ZodEnum":
    case "enum": {
      if (Array.isArray(def.values) && def.values.length > 0)
        return def.values[0];
      if (def.entries && typeof def.entries === "object") {
        const values = Object.values(def.entries);
        return values.length > 0 ? values[0] : "example";
      }
      return "example";
    }
    case "ZodOptional":
    case "optional":
    case "ZodNullable":
    case "nullable":
    case "ZodDefault":
    case "default": {
      const inner = def.innerType ?? def.wrapped;
      return inner ? generateExampleValue(inner) : null;
    }
    case "ZodArray":
    case "array":
      return [];
    case "ZodObject":
    case "object":
      return generateExamplePropsFromZod(schema);
    case "ZodUnion":
    case "union": {
      const options = def.options;
      return options && options.length > 0 ? generateExampleValue(options[0]) : "...";
    }
    default:
      return "...";
  }
}
function findFirstStringProp(schema) {
  if (!schema || !schema._def) return null;
  const def = schema._def;
  const typeName = getZodTypeName(schema);
  if (typeName !== "ZodObject" && typeName !== "object") return null;
  const shape = typeof def.shape === "function" ? def.shape() : def.shape;
  if (!shape) return null;
  for (const [key, value] of Object.entries(shape)) {
    const innerTypeName = getZodTypeName(value);
    if (innerTypeName === "ZodOptional" || innerTypeName === "optional" || innerTypeName === "ZodNullable" || innerTypeName === "nullable") {
      continue;
    }
    if (innerTypeName === "ZodString" || innerTypeName === "string") {
      return key;
    }
  }
  return null;
}
function getZodTypeName(schema) {
  if (!schema || !schema._def) return "";
  const def = schema._def;
  return def.typeName ?? def.type ?? "";
}
function formatZodType(schema) {
  if (!schema || !schema._def) return "unknown";
  const def = schema._def;
  const typeName = getZodTypeName(schema);
  switch (typeName) {
    case "ZodString":
    case "string":
      return "string";
    case "ZodNumber":
    case "number":
      return "number";
    case "ZodBoolean":
    case "boolean":
      return "boolean";
    case "ZodLiteral":
    case "literal":
      return JSON.stringify(def.value);
    case "ZodEnum":
    case "enum": {
      let values;
      if (Array.isArray(def.values)) {
        values = def.values;
      } else if (def.entries && typeof def.entries === "object") {
        values = Object.values(def.entries);
      } else {
        return "enum";
      }
      return values.map((v) => `"${v}"`).join(" | ");
    }
    case "ZodArray":
    case "array": {
      const inner = def.type ?? def.element;
      return inner ? `Array<${formatZodType(inner)}>` : "Array<unknown>";
    }
    case "ZodObject":
    case "object": {
      const shape = typeof def.shape === "function" ? def.shape() : def.shape;
      if (!shape) return "object";
      const props = Object.entries(shape).map(([key, value]) => {
        const innerTypeName = getZodTypeName(value);
        const isOptional = innerTypeName === "ZodOptional" || innerTypeName === "ZodNullable" || innerTypeName === "optional" || innerTypeName === "nullable";
        return `${key}${isOptional ? "?" : ""}: ${formatZodType(value)}`;
      }).join(", ");
      return `{ ${props} }`;
    }
    case "ZodOptional":
    case "optional":
    case "ZodNullable":
    case "nullable": {
      const inner = def.innerType ?? def.wrapped;
      return inner ? formatZodType(inner) : "unknown";
    }
    case "ZodUnion":
    case "union": {
      const options = def.options;
      return options ? options.map((opt) => formatZodType(opt)).join(" | ") : "unknown";
    }
    default:
      return "unknown";
  }
}
function zodToJsonSchema(schema) {
  const def = schema._def;
  const typeName = def.typeName ?? "";
  switch (typeName) {
    case "ZodString":
      return { type: "string" };
    case "ZodNumber":
      return { type: "number" };
    case "ZodBoolean":
      return { type: "boolean" };
    case "ZodLiteral":
      return { const: def.value };
    case "ZodEnum":
      return { enum: def.values };
    case "ZodArray": {
      const inner = def.type;
      return {
        type: "array",
        items: inner ? zodToJsonSchema(inner) : {}
      };
    }
    case "ZodObject": {
      const shape = def.shape?.();
      if (!shape) return { type: "object" };
      const properties = {};
      const required = [];
      for (const [key, value] of Object.entries(shape)) {
        properties[key] = zodToJsonSchema(value);
        const innerDef = value._def;
        if (innerDef.typeName !== "ZodOptional" && innerDef.typeName !== "ZodNullable") {
          required.push(key);
        }
      }
      return {
        type: "object",
        properties,
        required: required.length > 0 ? required : void 0,
        additionalProperties: false
      };
    }
    case "ZodRecord": {
      const valueType = def.valueType;
      return {
        type: "object",
        additionalProperties: valueType ? zodToJsonSchema(valueType) : true
      };
    }
    case "ZodOptional":
    case "ZodNullable": {
      const inner = def.innerType;
      return inner ? zodToJsonSchema(inner) : {};
    }
    case "ZodUnion": {
      const options = def.options;
      return options ? { anyOf: options.map(zodToJsonSchema) } : {};
    }
    case "ZodAny":
      return {};
    default:
      return {};
  }
}
function defineCatalog(schema, catalog) {
  return schema.createCatalog(catalog);
}

// src/prompt.ts
function isNonEmptySpec(spec) {
  if (!spec || typeof spec !== "object") return false;
  const s = spec;
  return typeof s.root === "string" && typeof s.elements === "object" && s.elements !== null && Object.keys(s.elements).length > 0;
}
var PATCH_INSTRUCTIONS = `IMPORTANT: The current UI is already loaded. Output ONLY the patches needed to make the requested change:
- To add a new element: {"op":"add","path":"/elements/new-key","value":{...}}
- To modify an existing element: {"op":"replace","path":"/elements/existing-key","value":{...}}
- To remove an element: {"op":"remove","path":"/elements/old-key"}
- To update the root: {"op":"replace","path":"/root","value":"new-root-key"}
- To add children: update the parent element with new children array

DO NOT output patches for elements that don't need to change. Only output what's necessary for the requested modification.`;
function buildUserPrompt(options) {
  const { prompt, currentSpec, state, maxPromptLength } = options;
  let userText = String(prompt || "");
  if (maxPromptLength !== void 0 && maxPromptLength > 0) {
    userText = userText.slice(0, maxPromptLength);
  }
  if (isNonEmptySpec(currentSpec)) {
    const parts2 = [];
    parts2.push(
      `CURRENT UI STATE (already loaded, DO NOT recreate existing elements):`
    );
    parts2.push(JSON.stringify(currentSpec, null, 2));
    parts2.push("");
    parts2.push(`USER REQUEST: ${userText}`);
    if (state && Object.keys(state).length > 0) {
      parts2.push("");
      parts2.push(`AVAILABLE STATE:
${JSON.stringify(state, null, 2)}`);
    }
    parts2.push("");
    parts2.push(PATCH_INSTRUCTIONS);
    return parts2.join("\n");
  }
  const parts = [userText];
  if (state && Object.keys(state).length > 0) {
    parts.push(`
AVAILABLE STATE:
${JSON.stringify(state, null, 2)}`);
  }
  parts.push(
    `
Remember: Output /root first, then interleave /elements and /state patches so the UI fills in progressively as it streams. Output each state patch right after the elements that use it, one per array item.`
  );
  return parts.join("\n");
}
export {
  ActionBindingSchema,
  ActionConfirmSchema,
  ActionOnErrorSchema,
  ActionOnSuccessSchema,
  ActionSchema,
  DynamicBooleanSchema,
  DynamicNumberSchema,
  DynamicStringSchema,
  DynamicValueSchema,
  SPEC_DATA_PART,
  SPEC_DATA_PART_TYPE,
  ValidationCheckSchema,
  ValidationConfigSchema,
  VisibilityConditionSchema,
  action,
  actionBinding,
  addByPath,
  applySpecPatch,
  applySpecStreamPatch,
  autoFixSpec,
  buildUserPrompt,
  builtInValidationFunctions,
  check,
  compileSpecStream,
  createJsonRenderTransform,
  createMixedStreamParser,
  createSpecStreamCompiler,
  defineCatalog,
  defineSchema,
  evaluateVisibility,
  executeAction,
  findFormValue,
  formatSpecIssues,
  getByPath,
  interpolateString,
  nestedToFlat,
  parseSpecStreamLine,
  pipeJsonRender,
  removeByPath,
  resolveAction,
  resolveActionParam,
  resolveBindings,
  resolveDynamicValue,
  resolveElementProps,
  resolvePropValue,
  runValidation,
  runValidationCheck,
  setByPath,
  validateSpec,
  visibility
};
//# sourceMappingURL=index.mjs.map